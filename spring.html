<!DOCTYPE html>


<!--
 | Generated by Apache Maven Doxia Site Renderer 2.0.0 from src/site/markdown/spring.md at 2025-11-10
 | Rendered using Apache Maven Fluido Skin 2.1.0
-->
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 2.0.0" />
    <title>Spring integration – Orne Config</title>
    <link rel="stylesheet" href="./css/apache-maven-fluido-2.1.0.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />
    <script src="./js/apache-maven-fluido-2.1.0.min.js"></script>
<script type="module">
      import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.0/dist/mermaid.esm.min.mjs';
      mermaid.init({ startOnLoad: true });
      document.querySelectorAll('.language-mermaid').forEach(s => s.parentElement.classList.remove("prettyprint"));
      await mermaid.run({
        querySelector: '.language-mermaid',
        suppressErrors: true,
      });
    </script>
  </head>
  <body>
    <a class="github-fork-ribbon right-top" href="https://github.com/orne-dev/java-config" data-ribbon="Fork me on GitHub">Fork me on GitHub</a>
    <div class="container-fluid container-fluid-top">
      <header>
        <div id="banner">
          <div class="pull-left"></div>
          <div class="pull-right"></div>
          <div class="clear"><hr/></div>
        </div>

        <div id="breadcrumbs">
          <ul class="breadcrumb">
        <li id="publishDate">Last Published: 2025-11-10<span class="divider">|</span>
</li>
          <li id="projectVersion">Version: 1.0.0</li>
          </ul>
        </div>
      </header>
      <div class="row-fluid">
        <header id="leftColumn" class="span2">
          <nav class="well sidebar-nav">
  <ul class="nav nav-list">
   <li class="nav-header">Overview</li>
    <li><a href="index.html">Introduction</a></li>
    <li><a href="config.html">API</a></li>
    <li><a href="setup.html">Setup</a></li>
    <li><a href="configurable.html">Configurable components</a></li>
    <li class="active"><a>Spring integration</a></li>
    <li><a href="commons.html">Apache Commons integration</a></li>
   <li class="nav-header">Project Documentation</li>
    <li><a href="project-info.html"><span class="icon-chevron-right"></span>Project Information</a></li>
    <li><a href="project-reports.html"><span class="icon-chevron-right"></span>Project Reports</a></li>
  </ul>
          </nav>
          <div class="well sidebar-nav">
            <div id="poweredBy">
              <div class="clear"></div>
              <div class="clear"></div>
<a href="https://maven.apache.org/" class="builtBy" target="_blank"><img class="builtBy" alt="Built by Maven" src="./images/logos/maven-feather.png" /></a>
            </div>
          </div>
        </header>
        <main id="bodyColumn" class="span10">
<section><a id="Spring_integration"></a>
<h1>Spring integration</h1>
<p>Spring Framework integration is fully supported.</p>
<p>Features and customizations are enabled on a per Spring context basis,
allowing different configurations to be applied on different contexts in case
of context hierarchies.
This means that child contexts <strong>do not inherit</strong> configurations from parent
contexts, and must be configured independently.
See the <a href="#Context_hierarchies">context hierarchies</a> section for more details.</p><section><a id="Spring_boot_auto-configuration"></a>
<h2>Spring boot auto-configuration</h2>
<p>The libray comes with a Spring Boot auto-configuration class that
enables all features provided by the library by default.
To use it, simply add the library dependency to the
application dependencies.</p>
<p>The auto-configuration can be disabled through the
standard <code>spring.autoconfigure.exclude</code> property,
excluding the <code>dev.orne.config.spring.SpringBootAutoConfigurer</code> class,
or the library specific <code>orne.config.spring.boot.starter.enabled</code> property.</p>
<p>Additionally, each feature can be disabled independently
through the following properties:</p>
<table class="table table-striped">
<thead>
<tr class="a">
<th>Property</th>
<th>Feature</th></tr></thead><tbody>
<tr class="b">
<td><code>orne.config.spring.boot.starter.injection.enabled</code></td>
<td><code>PreferredConfig</code> based injection</td></tr>
<tr class="a">
<td><code>orne.config.spring.boot.starter.configurable.enabled</code></td>
<td>Configurable components automatic configuration</td></tr></tbody>
</table>
</section><section><a id="Annotation_based_Full_features_activation"></a>
<h2>Annotation based Full features activation</h2>
<p>To enable all features provided by the library in Spring Framework add
the <code>EnableOrneConfig</code> annotation to the Java configuration class:</p>

<pre class="prettyprint"><code class="language-java">@Configuration
@EnableOrneConfig
class AppConfig {
    ...
}
</code></pre>
<p>This enables the following features:</p>
<ul>

<li>Default Spring <code>Environment</code> based <code>Config</code> instance.</li>
<li>Detection and registration of additional <code>Config</code> beans present on Spring context.</li>
<li>Usage of <code>Config</code> beans as <code>PropertySource</code>s on Spring applications.</li>
<li><code>PreferredConfig</code> based injection of <code>Config</code> instances into Spring beans.</li>
<li>Automatic configuration of <code>Configurable</code> beans.</li>
</ul>
<p>Default and additional <code>Config</code> customization can be achieved implementing the
<code>ConfigProviderCustomizer</code> interface, as described in the
<a href="#Default_Config_customization">customization</a> section.</p></section><section><a id="Independent_features_activation"></a>
<h2>Independent features activation</h2>
<p>Each of the available features can be enabled independently, allowing
fine grained control over the integration.</p><section><a id="Config_beans_as_PropertySources"></a>
<h3>Config beans as <code>PropertySources</code></h3>
<p>This feature requires no additional configuration.
When the <code>ConfigPropertySource</code> annotation is used on a <code>Configuration</code> bean,
it is automatically registered as a Spring <code>PropertySource</code>:</p>

<pre class="prettyprint"><code class="language-java">@Configuration
@ConfigPropertySource(&quot;appConfigPropertySource&quot;)
class AppConfig {

    @Bean(&quot;appConfigPropertySource&quot;)
    public Config appConfig() {
        ...
    }
}
</code></pre>
<p><strong>Note:</strong> Do not add <code>Environment</code> based <code>Config</code> instances to the hierarchy
of <code>PropertySource</code>s, as this would create a circular dependency and result
in a <code>StackOverflowError</code> when resolving properties from the Spring
<code>Environment</code>.</p></section><section><a id="PreferredConfig_based_injection"></a>
<h3><code>PreferredConfig</code> based injection</h3>
<p>The <code>PreferredConfig</code> based injection of <code>Config</code> instances into Spring beans
can be activated through the <code>EnablePreferredConfigInjection</code> annotation:</p>

<pre class="prettyprint"><code class="language-java">@Configuration
@EnablePreferredConfigInjection
class AppConfig {

    @Bean
    public ConfigSubtype myConfig(
            // Injection of default Config instance is supported too
            Config config) {
        return Config.as(
            ...,
            ConfigSubtype.class);
    }

    @Bean
    public MyComponent myComponent(
        @PreferredConfig(ConfigSubtype.class)
        Config config) {
        ...
    }
}
</code></pre>
<p>Default <code>Config</code> customization can be achieved implementing the
<code>ConfigProviderCustomizer</code> interface, as described in the
<a href="#Default_Config_customization">customization</a> section.</p></section><section><a id="Configurable_components"></a>
<h3>Configurable components</h3>
<p>Automatic configuration of <code>Configurable</code> beans can be enabled
through the <code>EnableConfigurableComponents</code> annotation.</p>

<pre class="prettyprint"><code class="language-java">@Configuration
@EnableConfigurableComponents
class AppConfig {

    @Bean
    public Configurable myConfigurableComponent() {
        ...
    }
}
</code></pre>
<p>The annotation registers under the hoods a <code>BeanPostProcessor</code> that
automatically applies the configuration to all beans implementing
the <code>Configurable</code> interface using an internal <code>Configurer</code> instance
populated with <code>Config</code> instances found on Spring context.</p>
<p>The <code>Configurer</code> is not exposed as a bean by default, but it can be
exposed setting the <code>exposeConfigurer</code> attribute to <code>true</code>:</p>

<pre class="prettyprint"><code class="language-java">@Configuration
@EnableConfigurableComponents(exposeConfigurer = true)
class AppConfig {

    @Autowired
    public void setConfigurer(Configurer configurer) {
        ...
    }
}
</code></pre>
<p>Default <code>Config</code> customization can be achieved implementing the
<code>ConfigProviderCustomizer</code> interface, as described in the
<a href="#Default_Config_customization">customization</a> section.</p></section></section><section><a id="Default_Config_customization"></a>
<h2>Default <code>Config</code> customization</h2>
<p>By default the library creates a <code>Config</code> instance based on the Spring
<code>Environment</code> and registers all <code>Config</code> beans found on the Spring context
as additional configurations.</p>
<p>This means that when a <code>Config</code> instance is requested the default
<code>Environment</code> based <code>Config</code> instance is used, unless a more specific <code>Config</code>
type is requested through the <code>PreferredConfig</code> annotation.</p>
<p>When additional <code>Config</code> beans are registered, they are mapped to the
interfaces extending <code>Config</code> that they implement, if no previous mapping
exists.
The order in wich the additional <code>Config</code> instances available in the
Spring context are registered is not guaranteed, so if multiple <code>Config</code>
instances implementing the same interface are present, the mapped instance
is indeterminate.</p>
<p>The library provides the <code>ConfigProviderCustomizer</code> interface to
customize the default <code>Config</code> instance and the registered <code>Config</code> beans.</p>
<p>A implementation of the interface can be registered as a Spring bean
on each Spring context:</p>

<pre class="prettyprint"><code class="language-java">@Configuration
@EnableOrneConfig
class AppConfiguration implements ConfigProviderCustomizer {

    @Override
    public Config configureDefaultConfig(
            Map&lt;String, Config&gt; configs) {
        // Customize and return the default Config instance.
    }

    @Override
    public void registerAdditionalConfigs(
            ConfigRegistry registry,
            Map&lt;String, Config&gt; configs) {
        // Fine tune the registration of additional Config instances.
        // Allows to control the order of registration and/or
        // register instances no present on the Spring context.
        ...
        // If desired, call the default implementation to
        // register all the instances present on the Spring context.
        ConfigProviderCustomizer.super.registerAdditionalConfigs(registry, configs);
    }
}
</code></pre>
<p>If more control is needed applications can provide their own
<code>ConfigProvider</code> bean implementation, bypassing the creation of the
internal <code>ConfigProvider</code>:</p>

<pre class="prettyprint"><code class="language-java">@Configuration
class AppConfiguration {

    @Bean
    public ConfigProvider configProvider() {
        // Create and return a custom ConfigProvider instance.
    }
}
</code></pre></section><section><a id="Context_hierarchies"></a>
<h2>Context hierarchies</h2>
<p>Features and customizations are enabled on a per Spring context basis,
allowing different configurations to be applied on different contexts in case
of context hierarchies.
This means that child context <strong>do not inherit</strong> features enabled in parent
contexts, and must be configured independently.</p>
<p>The following will not work as expected:</p>

<pre class="prettyprint"><code class="language-java">@Configuration
@EnableOrneConfig
class ParentConfig {

    @Bean
    public MyComponent parentComponent(
            Config config) {
        // No problem. Default Environment based configuration used
        ...
    }
}

@Configuration
class ChildConfig {

    @Bean
    public MyComponent myComponent(
            @PreferredConfig(ConfigSubtype.class)
            Config config) {
        // No Config instance is available for injection here
        // and no PreferredConfig based injection is supported
        ...
    }
}
</code></pre>
<p>Thus, if preferred <code>Config</code> instances should be injected into beans in a child
context, the child context must also enable the <code>PreferredConfig</code> based
injection feature through the <code>EnableOrneConfig</code> or
<code>EnablePreferredConfigInjection</code> annotation.
The same applies to the automatic configuration of <code>Configurable</code>
beans, which must be enabled in each context through the
<code>EnableOrneConfig</code> or <code>EnableConfigurableComponents</code> annotation.</p>
<p>Instances of <code>Config</code> created in a parent context are still visible
to child contexts, so they can be injected or used to configure
<code>Configurable</code> beans in child contexts.</p>

<pre class="prettyprint"><code class="language-java">@Configuration
@EnableOrneConfig
class ParentConfig {

    @Bean
    public ConfigSubtype myConfig(
            Config config) {
        return Config.as(
            ...,
            ConfigSubtype.class);
    }
}

@Configuration
@EnableOrneConfig
class ChildConfig {

    @Bean
    public MyComponent myComponent(
            @PreferredConfig(ConfigSubtype.class)
            Config config) {
        // Injected preferred Config instance comes from parent context
        ...
    }
}
</code></pre>
<p>Same applies to <code>ConfigProviderCustomizer</code> and application provided
<code>ConfigProvider</code> based customizations.
Customizations applied in a parent context do not affect child contexts,
which must provide their own customization if needed.</p></section></section>        </main>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>©      2019–2025
<a href="https://github.com/orne-dev">Orne Developments</a>
</p>
        </div>
      </div>
    </footer>
  </body>
</html>