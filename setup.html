<!DOCTYPE html>


<!--
 | Generated by Apache Maven Doxia Site Renderer 2.0.0 from src/site/markdown/setup.md at 2025-11-10
 | Rendered using Apache Maven Fluido Skin 2.1.0
-->
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 2.0.0" />
    <title>Creation of configuration instances – Orne Config</title>
    <link rel="stylesheet" href="./css/apache-maven-fluido-2.1.0.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />
    <script src="./js/apache-maven-fluido-2.1.0.min.js"></script>
<script type="module">
      import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.0/dist/mermaid.esm.min.mjs';
      mermaid.init({ startOnLoad: true });
      document.querySelectorAll('.language-mermaid').forEach(s => s.parentElement.classList.remove("prettyprint"));
      await mermaid.run({
        querySelector: '.language-mermaid',
        suppressErrors: true,
      });
    </script>
  </head>
  <body>
    <a class="github-fork-ribbon right-top" href="https://github.com/orne-dev/java-config" data-ribbon="Fork me on GitHub">Fork me on GitHub</a>
    <div class="container-fluid container-fluid-top">
      <header>
        <div id="banner">
          <div class="pull-left"></div>
          <div class="pull-right"></div>
          <div class="clear"><hr/></div>
        </div>

        <div id="breadcrumbs">
          <ul class="breadcrumb">
        <li id="publishDate">Last Published: 2025-11-10<span class="divider">|</span>
</li>
          <li id="projectVersion">Version: 1.0.0</li>
          </ul>
        </div>
      </header>
      <div class="row-fluid">
        <header id="leftColumn" class="span2">
          <nav class="well sidebar-nav">
  <ul class="nav nav-list">
   <li class="nav-header">Overview</li>
    <li><a href="index.html">Introduction</a></li>
    <li><a href="config.html">API</a></li>
    <li class="active"><a>Setup</a></li>
    <li><a href="configurable.html">Configurable components</a></li>
    <li><a href="spring.html">Spring integration</a></li>
    <li><a href="commons.html">Apache Commons integration</a></li>
   <li class="nav-header">Project Documentation</li>
    <li><a href="project-info.html"><span class="icon-chevron-right"></span>Project Information</a></li>
    <li><a href="project-reports.html"><span class="icon-chevron-right"></span>Project Reports</a></li>
  </ul>
          </nav>
          <div class="well sidebar-nav">
            <div id="poweredBy">
              <div class="clear"></div>
              <div class="clear"></div>
<a href="https://maven.apache.org/" class="builtBy" target="_blank"><img class="builtBy" alt="Built by Maven" src="./images/logos/maven-feather.png" /></a>
            </div>
          </div>
        </header>
        <main id="bodyColumn" class="span10">
<section><a id="Creation_of_configuration_instances"></a>
<h1>Creation of configuration instances</h1><section><a id="Configuration_sources"></a>
<h2>Configuration sources</h2>
<p>Interface <code>Config</code> provides static methods for start fluent creation of
configuration instances from different sources.</p>
<p>All configuration builders support additional options described in the
<a href="#Shared_options">Shared options</a> section.</p><section><a id="Environment_variables"></a>
<h3>Environment variables</h3>
<p>Configuration instance that retrieves values from environment variables
(<code>System.getenv()</code>) can be created using the
<code>Config.fromEnvironmentVariables()</code> method.</p>
<p>Example:</p>

<pre class="prettyprint"><code class="language-java">Config config = Config.fromEnvironmentVariables()
        .build();
String path = config.get(&quot;PATH&quot;);
</code></pre>
<p><strong>This configuration source is read-only.</strong></p></section><section><a id="System_properties"></a>
<h3>System properties</h3>
<p>Configuration instance that retrieves values from system properties
(<code>System.getProperties()</code>) can be created using the
<code>Config.fromSystemProperties()</code> method.</p>
<p>Example:</p>

<pre class="prettyprint"><code class="language-java">Config config = Config.fromSystemProperties()
        .build();
String userHome = config.get(&quot;user.home&quot;);
</code></pre>
<p><strong>This configuration source is read-only.</strong></p></section><section><a id="Java_Properties"></a>
<h3>Java Properties</h3>
<p>Configuration instance that uses Java <code>Properties</code> as storage mechanism
can be created using the <code>Config.fromProperties()</code> method.</p>
<p>Example:</p>

<pre class="prettyprint"><code class="language-java">Map&lt;String, String&gt; localValues = ...;
Config config = Config.fromProperties()
        .load(&quot;example/config.properties&quot;)
        .add(localValues) // Overrides loaded properties
        .build();
String host = config.get(&quot;host&quot;);
</code></pre>
<p>This configuration source supports watchable mutable configurations that
can be persisted on files or output streams.</p>
<p>Example:</p>

<pre class="prettyprint"><code class="language-java">Map&lt;String, String&gt; localValues = ...;
FileWatchableConfig config = Config.fromProperties()
        .load(&quot;example/config.properties&quot;)
        .add(localValues) // Overrides loaded properties
        .mutable()
        .build();
config.set(&quot;host&quot;, &quot;example.com&quot;);
config.remove(&quot;timeout&quot;);
Path path = ...;
config.save(path);
</code></pre></section><section><a id="JSON"></a>
<h3>JSON</h3>
<p>Jackson 2 based configuration instance that retrieves values from JSON files
or objects can be created using the <code>Config.fromJson()</code> method.</p>
<p><strong>Note:</strong> Requires Jackson 2.x <code>com.fasterxml.jackson.core:jackson-databind</code>
dependency.
The library declares dependency as optional, so it must be included explicitly
in the project dependencies.</p>
<p>Example:</p>

<pre class="prettyprint"><code class="language-java">Map&lt;String, String&gt; localValues = ...;
Config config = Config.fromJson()
        .load(&quot;config/application.json&quot;)
        .add(localValues) // Overrides loaded properties
        .build();
String host = config.get(&quot;host&quot;);
</code></pre>
<p>This configuration source supports watchable mutable configurations that
can be persisted on files or output streams.</p>
<p>Example:</p>

<pre class="prettyprint"><code class="language-java">Map&lt;String, String&gt; localValues = ...;
FileWatchableConfig config = Config.fromJson()
        .load(&quot;example/config.json&quot;)
        .add(localValues) // Overrides loaded properties
        .mutable()
        .build();
config.set(&quot;host&quot;, &quot;example.com&quot;);
config.remove(&quot;timeout&quot;);
Path path = ...;
config.save(path);
</code></pre></section><section><a id="YAML"></a>
<h3>YAML</h3>
<p>Jackson 2 based configuration instance that retrieves values from YAML files
or objects can be created using the <code>Config.fromYaml()</code> method.</p>
<p><strong>Note:</strong> Requires Jackson 2.x <code>com.fasterxml.jackson.dataformat:jackson-dataformat-yaml</code>
dependency.
The library declares dependency as optional, so it must be included explicitly
in the project dependencies.</p>
<p>Example:</p>

<pre class="prettyprint"><code class="language-java">Map&lt;String, String&gt; localValues = ...;
Config config = Config.fromYaml()
        .load(&quot;example/config.yml&quot;)
        .add(localValues) // Overrides loaded properties
        .build();
String host = config.get(&quot;host&quot;);
</code></pre>
<p>This configuration source supports watchable mutable configurations that
can be persisted on files or output streams.</p>
<p>Example:</p>

<pre class="prettyprint"><code class="language-java">Map&lt;String, String&gt; localValues = ...;
FileWatchableConfig config = Config.fromYaml()
        .load(&quot;example/config.yml&quot;)
        .add(localValues) // Overrides loaded properties
        .mutable()
        .build();
config.set(&quot;host&quot;, &quot;example.com&quot;);
config.remove(&quot;timeout&quot;);
Path path = ...;
config.save(path);
</code></pre></section><section><a id="XML_files"></a>
<h3>XML files</h3>
<p>Configuration instance that retrieves values from XML files
or documents can be created using the <code>Config.fromXml()</code> method.</p>
<p><strong>Note:</strong> This configuration source ignores root XML element when converting
XML structure into configuration properties.
When multiple files are loaded expects all files to share first loaded
document's root XML element.</p>
<p>Example:</p>

<pre class="prettyprint"><code class="language-java">Map&lt;String, String&gt; localValues = ...;
Config config = Config.fromXml()
        .load(&quot;example/config.xml&quot;)
        .add(localValues) // Overrides loaded properties
        .build();
String host = config.get(&quot;host&quot;);
</code></pre>
<p>This configuration source supports watchable mutable configurations that
can be persisted on files or output streams.</p>
<p>Example:</p>

<pre class="prettyprint"><code class="language-java">Map&lt;String, String&gt; localValues = ...;
FileWatchableConfig config = Config.fromXml()
        .load(&quot;example/config.xml&quot;)
        .add(localValues) // Overrides loaded properties
        .mutable()
        .build();
config.set(&quot;host&quot;, &quot;example.com&quot;);
config.remove(&quot;timeout&quot;);
Path path = ...;
config.save(path);
</code></pre></section><section><a id="Spring_environment"></a>
<h3>Spring environment</h3>
<p>Configuration instance that retrieves values from Spring environment properties
can be created using the <code>Config.fromSpringEnvironment()</code> method.</p>
<p>Example:</p>

<pre class="prettyprint"><code class="language-java">Environment env = ...;
Config config = Config.fromSpringEnvironment()
        .ofEnvironment(env)
        .build();
String host = config.get(&quot;host&quot;);
</code></pre>
<p>By default Spring <code>Environment</code> does not allow iteration over properties keys,
but <code>ConfigurableEnvironment</code> does iterating over <code>EnumerablePropertySource</code>
properties, which is the most common scenario.
To enable iterable keys support, use the <code>withIterableKeys()</code> method:</p>

<pre class="prettyprint"><code class="language-java">ConfigurableEnvironment env = ...;
Config config = Config.fromSpringEnvironment()
        .ofEnvironment(env)
        .withIterableKeys()
        .build();
if (config.contains(&quot;host&quot;)) {
    String host = config.get(&quot;host&quot;);
}
</code></pre>
<p><strong>This configuration source is read-only.</strong></p></section><section><a id="Java_Preferences"></a>
<h3>Java Preferences</h3>
<p>Configuration instance that uses Java <code>Preferences</code> as storage mechanism
can be created using the <code>Config.fromJavaPreferences()</code> method.</p>
<p>Example:</p>

<pre class="prettyprint"><code class="language-java">String path = ...;
Config config = Config.fromJavaPreferences()
        .ofUser(path)
        .build();
String host = config.get(&quot;host&quot;);
</code></pre>
<p>This configuration source supports watchable mutable configurations that
can be synchronized with persisted on files or output streams.</p>
<p>Example:</p>

<pre class="prettyprint"><code class="language-java">String path = ...;
PreferencesMutableConfig config = Config.fromJavaPreferences()
        .ofUser(path)
        .mutable()
        .build();
config.set(&quot;host&quot;, &quot;example.com&quot;);
config.remove(&quot;timeout&quot;);
// Synchronize changes to the underlying Preferences storage
config.sync();
// Flush changes to the persistent storage
config.flush();
</code></pre></section><section><a id="Apache_Commons_Configuration"></a>
<h3>Apache Commons Configuration</h3>
<p>Configuration instance that delegates on Apache Commons
<code>ImmutableConfiguration</code> can be created using the
<code>Config.fromApacheCommons()</code> method.</p>
<p>Example:</p>

<pre class="prettyprint"><code class="language-java">ImmutableConfiguration delegated = ...;
Config config = Config.fromApacheCommons()
        .ofDelegate(delegated)
        .build();
String host = config.get(&quot;host&quot;);
</code></pre>
<p>This configuration source supports watchable mutable configurations
delegated on .</p>
<p>Example:</p>

<pre class="prettyprint"><code class="language-java">Configuration delegated = ...;
WatchableConfig config = Config.fromApacheCommons()
        .ofDelegate(delegated)
        .mutable()
        .build();
config.set(&quot;host&quot;, &quot;example.com&quot;);
config.remove(&quot;timeout&quot;);
</code></pre></section></section><section><a id="Shared_options"></a>
<h2>Shared options</h2><section><a id="Mutable_configurations"></a>
<h3>Mutable configurations</h3>
<p>When supported by the underlying configuration source, configuration
instances can be made mutable using the <code>mutable()</code> method,
allowing to set and remove configuration values.</p></section><section><a id="Configuration_hierarchy"></a>
<h3>Configuration hierarchy</h3>
<p>A configuration can inherit values from a parent configuration declared
during the building process using the <code>withParent()</code> method.</p>
<p>This allows to create a hierarchy of configurations, where child
configurations can inherit values from their parent configurations.</p>
<p>A tipical use case is to have a base configuration for the application,
inhiriting environment variables and system properties,
that can be extended by environment specific configurations, like
development, testing and production configurations.</p>
<p>Example:</p>

<pre class="prettyprint"><code class="language-java">Config baseConfig = ConfigProvider.fromProperties()
    .load(&quot;example/base.properties&quot;)
    .withParent(Config.fromSystemProperties()
        .withParent(Config.fromEnvironmentVariables()))
    .build();
Config config = ConfigProvider.fromProperties()
    .load(&quot;example/dev.properties&quot;)
    .withParent(baseConfig)
    .build();
</code></pre><section><a id="Merging_strategy"></a>
<h4>Merging strategy</h4>
<p>By default, when a configuration has a parent, the parent values have
precedence over the child values. This means that if both configurations have
a value for a given key, the parent configuration will provide the value for
that key.</p>
<p>This behavior can be changed during the building process using the
<code>withOverrideParentProperties()</code> method. When this method is used, the child
configuration will have precedence over the parent configuration, meaning that
if both configurations have a value for a given key, the child configuration will
override the parent configuration and provide the value for that key.</p>
<p>Example:</p>

<pre class="prettyprint"><code class="language-java">Config baseConfig = ConfigProvider.fromProperties()
    .load(&quot;example/base.properties&quot;)
    .withParent(Config.fromSystemProperties()
        .withParent(Config.fromEnvironmentVariables())
        .build())
    .build();
Config config = ConfigProvider.fromProperties()
    .load(&quot;example/dev.properties&quot;)
    .withParent(baseConfig)
    .withOverrideParentProperties()
    .build();
</code></pre></section></section><section><a id="Decoders"></a>
<h3>Decoders</h3>
<p>Decoders allow decoding the configuration property values at runtime,
by applying a transformation function to the values retrieved from the
underlying configuration source.</p>
<p>This is useful for handling sensitive configuration values,
like API keys or passwords, that should be stored in an encoded format
in the configuration source, and decoded when retrieved
for usage.</p>
<p>This is enabled using the <code>withDecoder()</code> method
during the building process, allowing to chain multiple decoders.</p>
<p>Example:</p>

<pre class="prettyprint"><code class="language-java">ValueDecoder parentDecode = ...;
Config parent = Config.fromProperties()
        .add(Map.of(
            &quot;api.key&quot;, &quot;my_encoded_api_key&quot;))
        .withDecoder(parentDecode)
        .build();
ValueDecoder decode = ...;
Config config = Config.fromProperties()
        .add(Map.of(
            &quot;api.child.key&quot;, &quot;my_encoded_child_api_key&quot;))
        .withParent(parent)
        .withDecoder(decode)
        .build();
String apiKey = config.get(&quot;api.child.key&quot;);
// apiKey will be the result of decode(&quot;my_encoded_child_api_key&quot;)
String parentApiKey = config.get(&quot;api.key&quot;);
// parentApiKey will be the result of parentDecode(&quot;my_encoded_api_key&quot;)
</code></pre></section><section><a id="Encoders"></a>
<h3>Encoders</h3>
<p>Encoders allow encoding the configuration property values at runtime,
by applying a transformation function to the values set in the
underlying configuration source.</p>
<p>This is useful for handling sensitive configuration values,
like API keys or passwords, that should be stored in an encoded format
in the configuration source, and encoded when set.</p>
<p>This is enabled using the <code>withEncoder()</code> method
during the building process, allowing to chain multiple encoders.</p>
<p>Example:</p>

<pre class="prettyprint"><code class="language-java">ValueEncoder parentEncode = ...;
MutableConfig parent = Config.fromProperties()
        .mutable()
        .withEncoder(parentEncode)
        .build();
ValueEncoder encode = ...;
MutableConfig config = Config.fromProperties()
        .withParent(parent)
        .mutable()
        .withEncoder(encode)
        .build();
config.set(&quot;api.key&quot;, &quot;my_plain_api_key&quot;);
// The value stored in the underlying configuration source of config
// will be the result encode(&quot;my_plain_api_key&quot;)
parent.set(&quot;api.key&quot;, &quot;my_plain_api_key&quot;);
// The value stored in the underlying configuration source of parent
// will be the result of parentEncode(&quot;my_plain_api_key&quot;)
</code></pre></section><section><a id="Cryptographic_encoders_and_decoders"></a>
<h3>Cryptographic encoders and decoders</h3>
<p>A special type of encoders and decoders are the cryptographic encoders
and decoders, that allow to encode and decode configuration property values
using cryptographic algorithms, like AES.</p>
<p>This is enabled using the <code>withEncryption()</code> methods during the building
process, passing a <code>ConfigCryptoProvider</code> instance that provides the
cryptographic transformations.</p>
<p>Example:</p>

<pre class="prettyprint"><code class="language-java">ConfigCryptoProvider crypto = ConfigCryptoProvider.builder()
        .withAesGcmEngine(&quot;secretSalt&quot;.getBytes(StandardCharsets.UTF_8))
        .withSecretKey(&quot;secretKey&quot;.toCharArray())
        .build();
MutableConfig config = Config.fromProperties()
        .add(Map.of(
            &quot;api.key&quot;, &quot;my_encoded_api_key&quot;))
        .withEncryption(crypto)
        .mutable()
        .build();
String apiKey = config.get(&quot;api.key&quot;);
// apiKey will be the decrypted value of &quot;my_encoded_api_key&quot;
config.set(&quot;api.key&quot;, &quot;my_plain_api_key&quot;);
// The value stored in the underlying configuration source of config
// will be the encrypted value of &quot;my_plain_api_key&quot;
</code></pre>
<p>Library provides built-in support for AES-GCM
algorithm. Additional algorithms can be implemented by providing custom
<code>ConfigCryptoEngine</code> implementations passed to
<code>CryptoProviderEngineBuilder.withEngine()</code>:</p>

<pre class="prettyprint"><code class="language-java">ConfigCryptoEngine myCustomCryptoEngine = ...;
ConfigCryptoProvider crypto = ConfigCryptoProvider.builder()
        .withEngine(myCustomCryptoEngine)
        .withSecretKey(&quot;secretKey&quot;.toCharArray())
        .build();
</code></pre>
<p>Cryptographic encoders can be used in read-only configurations as well,
to decode encrypted configuration property values.
Example:</p>

<pre class="prettyprint"><code class="language-java">ConfigCryptoProvider crypto = ...;
Config config = Config.fromProperties()
        .add(Map.of(
            &quot;api.key&quot;, &quot;my_encoded_api_key&quot;))
        .withEncryption(crypto)
        .build();
String apiKey = config.get(&quot;api.key&quot;);
// apiKey will be the decrypted value of &quot;my_encoded_api_key&quot;
</code></pre>
<p>Cryptographic encoders and decoders can be chained with other
encoders and decoders as well.</p>
<p>Example:</p>

<pre class="prettyprint"><code class="language-java">ConfigCryptoProvider crypto = ...;
ValueDecoder decode = ...;
ValueEncoder encode = ...;
MutableConfig config = Config.fromProperties()
        .add(Map.of(
            &quot;api.key&quot;, &quot;my_encoded_api_key&quot;))
        .withEncryption(crypto)
        .withDecoder(decode)
        .withEncoder(encode)
        .mutable()
        .build();
String apiKey = config.get(&quot;api.key&quot;);
// apiKey will be the result of decode(decrypted(&quot;my_encoded_api_key&quot;))
config.set(&quot;api.key&quot;, &quot;my_plain_api_key&quot;);
// The value stored in the underlying configuration source of config
// will be the encrypted(encode(&quot;my_plain_api_key&quot;))
</code></pre></section><section><a id="Decorators"></a>
<h3>Decorators</h3>
<p>Decorators allow modifying the configuration property values at runtime,
by applying a transformation function to the values retrieved from the
underlying configuration sources.</p>
<p>In oposition to decoders, decorators will modify only final values returned
by the configuration instance, thus a decorator on the parent configuration
will not affect the child configuration values, even if inherited from the
parent.</p>
<p>This is enabled using the <code>withDecorator()</code> method
during the building process, allowing to chain multiple decorators.</p>
<p>Example:</p>

<pre class="prettyprint"><code class="language-java">ValueDecorator parentDecorate = ...;
Config parent = Config.fromProperties()
        .add(Map.of(
            &quot;host&quot;, &quot;example.com&quot;))
        .withDecorator(parentDecorate)
        .build();;
ValueDecorator decorate = ...;
Config config = Config.fromProperties()
        .withParent(parent)
        .withDecorator(decorate)
        .build();
String host = config.get(&quot;host&quot;);
// host will be the result of decorate(&quot;example.com&quot;)
String parentHost = parent.get(&quot;host&quot;);
// parentHost will be the result of parentDecorate(&quot;example.com&quot;)
</code></pre></section><section><a id="Variable_resolution"></a>
<h3>Variable resolution</h3>
<p>A special type of decorator is the variable resolution decorator,
that allows to use variables in configuration values, that will be
resolved with other configuration values at runtime.
This is enabled using the <code>withVariableResolution()</code> method
during the building process, allowing usage of multiple configuration
sources in the configuration hierarchy.</p>
<p>Example:</p>

<pre class="prettyprint"><code class="language-java">Config config = Config.fromProperties()
        .add(Map.of(
            &quot;host&quot;, &quot;example.com&quot;,
            &quot;port&quot;, &quot;80&quot;))
        .withParent(Config.fromProperties()
            .add(Map.of(
                &quot;service.url&quot;, &quot;http://${host}:${port}/api&quot;,
                &quot;host&quot;, &quot;localhost&quot;,
                &quot;port&quot;, &quot;8080&quot;)))
        .withOverrideParentProperties()
        .withVariableResolution()
        .build();
String url = config.get(&quot;service.url&quot;);
// url will be &quot;http://example.com:80/api&quot;
String parentUrl = config.getParent().get(&quot;service.url&quot;);
// parentUrl will be &quot;http://${host}:${port}/api&quot;, as doesn't have variable resolution enabled
</code></pre>
<p>Variable substitutors can be chained with other decorators as well.</p>
<p>Example:</p>

<pre class="prettyprint"><code class="language-java">ValueDecorator decorate = value -&gt; &quot;decorated[&quot; + value + &quot;]&quot;;
Config config = Config.fromProperties()
        .add(Map.of(
            &quot;service.url&quot;, &quot;http://${host}:${port}/api&quot;,
            &quot;host&quot;, &quot;localhost&quot;,
            &quot;port&quot;, &quot;8080&quot;))
        .withVariableResolution()
        .withDecorator(decorate)
        .build();
String url = config.get(&quot;service.url&quot;);
// url will be &quot;decorated[http://decorated[localhost]:decorated[8080]/api]&quot;
</code></pre></section></section></section>        </main>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>©      2019–2025
<a href="https://github.com/orne-dev">Orne Developments</a>
</p>
        </div>
      </div>
    </footer>
  </body>
</html>